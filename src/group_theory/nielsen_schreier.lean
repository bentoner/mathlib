/-
Copyright (c) 2021 David Wärn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Wärn
-/
import category_theory.action
  group_theory.free_group
  group_theory.semidirect_product
  combinatorics.quiver

/-!
# The Nielsen-Schreier theorem

This file will eventually prove that a subgroup of a free group is itself free.

## Proof sketch

The proof is analogous to the classical proof in terms of fundamental groups of graphs,
but we work directly with groupoids instead of spaces. The main steps are as follows

- Given a subgroup `H` of a free group `G`, observe that `H` is the stabilizer of `1H` in
  the action of `G` on `G / H`. Moreover, whenever `G` acts on a set `A`, there is a
  corresponding action groupoid (with object set `A`), and stabilizers are precisely
  vertex groups in this groupoid. (This corresponds to the observation that `H` is a
  fundamental group in a certain covering space.)

- Say a groupoid `G` is _freely generated_ by a family `D` of morphisms if defining a functor
  from `G` to a group `X` is equivalent to assigning a value in `X` to every morphism in `D`.
  (Free groupoids play the same role as topological graphs.)

- Show that if a free group `G` acts on a set `A`, then the corresponding action groupoid is
  freely generated by morphisms lying above generators of `G`. To prove this, we show that
  functors from the action groupoid to a group `X` correspond to group homomorphism
  from `G` to the semidirect product `G ⋉ (A → X)`. (This corresponds to the fact that
  a covering space of a graph is a graph.)

- Show that if a groupoid `G` is freely generated by `D` and `D` has a spanning tree `T`,
  then a vertex group in `G` is freely generated by certain elements coming from
  the complement of `T`. (This corresponds to retracting `T` to a point.)

This finishes the proof, modulo finding an appropriate rooted subtree.
-/

universes v u

open category_theory opposite category_theory.action_category semidirect_product

/-- `is_free_group G` means that `G` has the universal property of a free group.
    That is, it has a family `generators G` of elements, such that a group homomorphism
    `G →* X` is uniquely determined by a function `generators G → X`. -/
class is_free_group (G) [group.{u} G] :=
(generators : Type u)
(of : generators → G)
(unique_lift : ∀ {X} [group.{u} X] (f : generators → X),
                ∃! F : G →* X, ∀ a, F (of a) = f a)

instance {A} : is_free_group (free_group A) :=
{ generators := A,
  of := free_group.of,
  unique_lift := by { introsI X _ f, exact ⟨free_group.lift f, λ _, free_group.lift.of,
      λ g hg, monoid_hom.ext (λ _, free_group.lift.unique g hg)⟩ } }

namespace is_free_group

lemma end_is_id {G} [group G] [is_free_group G] (f : G →* G)
  (h : ∀ a, f (of a) = of a) : ∀ g, f g = g :=
let ⟨_, _, u⟩ := unique_lift (f ∘ of) in
have claim : f = monoid_hom.id G := (u _ (λ _, rfl)).trans (u _ (by simp [h])).symm,
monoid_hom.ext_iff.mp claim

/-- An abstract free group is isomorphic to a concrete free group. -/
noncomputable def iso_free_group_of_is_free_group (G) [group G] [is_free_group G] :
  G ≃* free_group (generators G) :=
let ⟨F, hF, uF⟩ := classical.indefinite_description _ (unique_lift free_group.of) in
{ to_fun := F,
  inv_fun := free_group.lift of,
  left_inv := end_is_id ((free_group.lift of).comp F) (by simp [hF]),
  right_inv := by { suffices : F.comp (free_group.lift of) = monoid_hom.id _,
    { rwa monoid_hom.ext_iff at this }, apply free_group.ext_hom, simp [hF] },
  map_mul' := F.map_mul }

/-- Being a free group transports across group isomorphisms. -/
def of_mul_equiv {G H} [group G] [group H] (h : G ≃* H) [is_free_group G] : is_free_group H :=
{ generators := generators G,
  of := h ∘ of,
  unique_lift := begin
    introsI X _ f,
    rcases unique_lift f with ⟨F, hF, uF⟩,
    refine ⟨F.comp h.symm.to_monoid_hom, by simp [hF], _⟩,
    intros F' hF',
    suffices : F'.comp h.to_monoid_hom = F,
    { rw ←this, ext, simp },
    apply uF,
    simp [hF'],
  end }

end is_free_group

/-- A groupoid `G` is free when we have the following data:
 - a quiver `generators G` whose vertices are objects of `G`
 - a function `of` sending an arrow in `generators G` to a morphism in `G`
 - such that a functor from `G` to any group `X` is uniquely determined
   by assigning labels in `X` to the vertices of `X`. -/
class is_free_groupoid (G) [groupoid.{v} G] :=
(generators : quiver.{v+1} G)
(of : Π ⦃a b⦄, generators.arrow a b → (a ⟶ b))
(unique_lift : ∀ X [group.{v} X] (f : generators.labelling X),
                ∃! F : G ⥤ single_obj X, ∀ a b (g : generators.arrow a b),
                  F.map (of g) = f g)

namespace is_free_groupoid.covering

instance {G A X : Type*} [monoid G] [mul_action G A] : mul_action Gᵒᵖ (A → X) :=
{ smul := λ g' F a, F (g'.unop • a),
  one_smul := by simp,
  mul_smul := by simp [mul_smul] }

@[simp] lemma arrow_action_apply {G A X : Type*} [monoid G] [mul_action G A]
  (g : Gᵒᵖ) (F : A → X) (a : A) : (g • F) a = F (g.unop • a) := rfl

/-- Given groups `G X` with `G` acting on `A`,
    `Gᵒᵖ` acts by multiplicative automorphisms on `A → X`. -/
def mul_aut_of_action (G A X) [group G] [mul_action G A] [has_mul X] :
  Gᵒᵖ →* mul_aut (A → X) :=
{ to_fun := λ g, {
    to_fun := λ F, g • F,
    inv_fun := λ F, g⁻¹ • F,
    left_inv := λ F, inv_smul_smul g F,
    right_inv := λ F, smul_inv_smul g F,
    map_mul' := by { intros, funext, simp only [arrow_action_apply, pi.mul_apply]} },
  map_one' := by { ext, simp only [mul_aut.one_apply, mul_equiv.coe_mk, one_smul]},
  map_mul' := by {intros, ext, simp only [mul_smul, mul_equiv.coe_mk, mul_aut.mul_apply] } }

@[simp] lemma mul_aut_of_action_apply {G A X : Type*} [group G] [mul_action G A] [has_mul X]
  (g : Gᵒᵖ) (F : A → X) (a : A) : mul_aut_of_action G A X g F a = F (g.unop • a) := rfl

/-- A group homomorphisms `G →* Hᵒᵖ` is the sa-/
def hom_op_equiv_op_hom {G H} [monoid G] [monoid H] :
  (G →* Hᵒᵖ) ≃ (Gᵒᵖ →* H) :=
{ to_fun := λ f, { to_fun := λ g', (f g'.unop).unop,
    map_one' := by simp, map_mul' := by simp },
  inv_fun := λ f, { to_fun := λ g, op (f (op g)),
    map_one' := by simp, map_mul' := by simp },
  left_inv := by { intro, ext, simp },
  right_inv := by { intro, ext, simp } }

/-- Given `G` acting on `A`, a functor from the corresponding action groupoid to a group `X`
    can be curried to a group homomorphism `G →* G ⋉ (A → X)`.
    (We simulate `⋉` using `⋊` and lots of `ᵒᵖ`s.) -/
def curry {G A X} [group G] [mul_action G A] [group X]
  (F : action_category G A ⥤ single_obj X) :
  G →* ((A → Xᵒᵖ) ⋊[mul_aut_of_action G A Xᵒᵖ] Gᵒᵖ)ᵒᵖ :=
have F_map_eq : ∀ {a b} {f : a ⟶ b}, F.map f = (F.map (hom_of_pair a.snd f.val) : X) :=
  action_category.cases (λ _ _, rfl),
{ to_fun := λ g, op ⟨λ a, op (F.map (hom_of_pair a g)), op g⟩,
  map_one' := begin
    rw [op_eq_iff_eq_unop, unop_one],
    congr, funext,
    rw [pi.one_apply, op_eq_iff_eq_unop, unop_one],
    exact (F_map_eq.congr rfl).mp (F.map_id a),
  end,
  map_mul' := begin
    intros g h,
    rw [op_eq_iff_eq_unop, ←op_mul, unop_op],
    congr, funext,
    rw [op_eq_iff_eq_unop, pi.mul_apply, unop_mul, unop_op],
    exact (F_map_eq.congr rfl).mp (F.map_comp (hom_of_pair a h) (hom_of_pair (h • a) g)),
  end }

/-- Given `G` acting on `A`, a group homomorphism `φ : G →* G ⋉ (A → X)` can be uncurried to
    a functor from the action groupoid to `X`, provided that `φ g = (g, _)` for all `g`.
    (We simulate `⋉` using `⋊` and lots of `ᵒᵖ`s.) -/
def uncurry {G A X} [group G] [mul_action G A] [group X]
  (F : G →* ((A → Xᵒᵖ) ⋊[mul_aut_of_action G A Xᵒᵖ] Gᵒᵖ)ᵒᵖ)
  (sane : ∀ g, (F g).unop.right.unop = g) :
  action_category G A ⥤ single_obj X :=
{ obj := λ _, (),
  map := λ a b f, ((F f.val).unop.left a.snd).unop,
  map_id' := by { intro x, rw [action_category.id_val, F.map_one], refl },
  map_comp' := by {
    intros x y z f, revert x y f,
    refine action_category.cases _, intros x g f,
    rw [action_category.comp_val, F.map_mul, unop_mul,
        mul_left, pi.mul_apply, mul_aut_of_action_apply, sane],
    refl } }

open is_free_group

noncomputable instance {G A} [group G] [is_free_group G] [mul_action G A] :
  is_free_groupoid (action_category G A) :=
{ generators := ⟨λ a b, { e : generators G // (of e • a.snd : A) = b.snd }⟩,
  of := λ a b e, ⟨of e, e.property⟩,
  unique_lift := begin
    introsI X _ f,
    let X' := ((A → Xᵒᵖ) ⋊[mul_aut_of_action G A Xᵒᵖ] Gᵒᵖ)ᵒᵖ,
    let f' : generators G → X' := λ e, op ⟨λ a, op (@f a (_ : A) ⟨e, rfl⟩), op (of e)⟩,
    rcases unique_lift f' with ⟨F', hF', uF'⟩,
    let F : action_category G A ⥤ single_obj X := uncurry F' _,
    refine ⟨F, _, _⟩,
    { rintros ⟨⟨⟩, a : A⟩ ⟨⟨⟩, b⟩ ⟨e, h : of e • a = b⟩,
      change ((F' (of _)).unop.left _).unop = _,
      rw hF', cases h, refl },
    { intros E hE,
      let E' := curry E,
      have : E' = F',
      { apply uF',
        intro e,
        refine unop_injective (semidirect_product.ext _ _ _ rfl),
        funext,
        change op (E.map _) = op (f _),
        rw [op_eq_iff_eq_unop, unop_op],
        exact hE _ _ ⟨e, _⟩ },
      apply functor.hext,
      { intro, apply unit.ext },
      { refine action_category.cases _, intros,
        change _ == ((F' _).unop.left _).unop,
        rw ←this, refl } },
    { apply end_is_id ((hom_op_equiv_op_hom (right_hom : _ →* Gᵒᵖ)).comp F'),
      intro, rw [monoid_hom.comp_apply, hF'], refl }
  end }

end is_free_groupoid.covering
