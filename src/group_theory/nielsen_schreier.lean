/-
Copyright (c) 2021 David W√§rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David W√§rn
-/
import category_theory.action
import category_theory.is_connected
import combinatorics.quiver
import group_theory.free_group
import group_theory.semidirect_product
/-!
# The Nielsen-Schreier theorem

This file proves that a subgroup of a free group is itself free.

## Main definitions

- `is_free_group G`: a class expressing that `G` has the universal property of a free group.
- `subgroup_is_free H`: an instance saying that a subgroup of a free group is free.

## Proof overview

The proof is analogous to the proof using covering spaces and fundamental groups of graphs,
but we work directly with groupoids instead of topological spaces. Under this analogy,

- `is_free_groupoid G` corresponds to saying that a space is a graph.
- `End_mul_equiv_subgroup H` plays the role of replacing 'subgroup of fundamental group' with
  'fundamental group of covering space'.
- `action_category_is_free G A` corresponds to the fact that a covering of a (single-vertex)
  graph is a graph.
- `End_is_free_group_of_arborescence` corresponds to the fact that, given a spanning tree of a
  graph, its fundamental group is free (generated by loops from the complement of the tree).

## Implementation notes

This proof works with the universal property `is_free_group` instead of the concrete description
`free_group A` of free groups. The two are related by `free_group_is_free_group` and
`iso_free_group_of_is_free_group`.

Our definition of `is_free_groupoid` is nonstandard. Normally one would require that functors
`G ‚•§ X` to any _groupoid_ `X` are given by graph homomorphisms from the generators, but we only
consider _groups_ `X`. This simplifies the argument since functor equality is complicated in
general, but simple for functors to single object categories.

## References

https://ncatlab.org/nlab/show/Nielsen-Schreier+theorem

## Tags

free group, Nielsen-Schreier

-/

noncomputable theory
open_locale classical
universes v u

open category_theory category_theory.action_category semidirect_product

/-- `is_free_group G` means that `G` has the universal property of a free group.
    That is, it has a family `generators G` of elements, such that a group homomorphism
    `G ‚Üí* X` is uniquely determined by a function `generators G ‚Üí X`. -/
class is_free_group (G) [group.{u} G] :=
(generators : Type u)
(of : generators ‚Üí G)
(unique_lift : ‚àÄ {X} [group.{u} X] (f : generators ‚Üí X),
                ‚àÉ! F : G ‚Üí* X, ‚àÄ a, F (of a) = f a)

instance free_group_is_free_group {A} : is_free_group (free_group A) :=
{ generators := A,
  of := free_group.of,
  unique_lift := by { introsI X _ f, exact ‚ü®free_group.lift f, Œª _, free_group.lift.of,
      Œª g hg, monoid_hom.ext (Œª _, free_group.lift.unique g hg)‚ü© } }

namespace is_free_group

lemma end_is_id {G} [group G] [is_free_group G] (f : G ‚Üí* G)
  (h : ‚àÄ a, f (of a) = of a) : ‚àÄ g, f g = g :=
let ‚ü®_, _, u‚ü© := unique_lift (f ‚àò of) in
have claim : f = monoid_hom.id G := trans (u _ (Œª _, rfl)) (u _ (by simp [h])).symm,
monoid_hom.ext_iff.mp claim

/-- An abstract free group is isomorphic to a concrete free group. -/
def iso_free_group_of_is_free_group (G) [group G] [is_free_group G] :
  G ‚âÉ* free_group (generators G) :=
let ‚ü®F, hF, uF‚ü© := classical.indefinite_description _ (unique_lift free_group.of) in
{ to_fun := F,
  inv_fun := free_group.lift of,
  left_inv := end_is_id ((free_group.lift of).comp F) (by simp [hF]),
  right_inv := by { suffices : F.comp (free_group.lift of) = monoid_hom.id _,
    { rwa monoid_hom.ext_iff at this }, apply free_group.ext_hom, simp [hF] },
  map_mul' := F.map_mul }

/-- Being a free group transports across group isomorphisms. -/
def of_mul_equiv {G H : Type u} [group G] [group H] (h : G ‚âÉ* H) [is_free_group G] :
  is_free_group H :=
{ generators := generators G,
  of := h ‚àò of,
  unique_lift := begin
    introsI X _ f,
    rcases unique_lift f with ‚ü®F, hF, uF‚ü©,
    refine ‚ü®F.comp h.symm.to_monoid_hom, by simp [hF], _‚ü©,
    intros F' hF',
    suffices : F'.comp h.to_monoid_hom = F,
    { rw ‚Üêthis, ext, simp },
    apply uF,
    simp [hF'],
  end }

end is_free_group

/-- A groupoid `G` is free when we have the following data:
 - a quiver `generators` whose vertices are objects of `G`
 - a function `of` sending an arrow in `generators` to a morphism in `G`
 - such that a functor from `G` to any group `X` is uniquely determined
   by assigning labels in `X` to the arrows in `generators. -/
class is_free_groupoid (G) [groupoid.{v} G] :=
(generators : quiver.{v+1} G)
(of : Œ† ‚¶Éa b‚¶Ñ, generators.arrow a b ‚Üí (a ‚ü∂ b))
(unique_lift : ‚àÄ {X} [group.{v} X] (f : generators.labelling X),
                ‚àÉ! F : G ‚•§ single_obj X, ‚àÄ a b (g : generators.arrow a b),
                  F.map (of g) = f g)

namespace is_free_groupoid

@[ext]
lemma ext_functor {G X} [groupoid.{v} G] [is_free_groupoid G] [group.{v} X]
  (f g : G ‚•§ single_obj X)
  (h : ‚àÄ a b (e : generators.arrow a b), f.map (of e) = g.map (of e)) :
  f = g :=
match unique_lift (show generators.labelling X, from Œª a b e, g.map (of e)) with
| ‚ü®m, _, um‚ü© := trans (um _ h) (um _ (Œª _ _ _, rfl)).symm
end

namespace covering

@[simps] def arrow_action {G A X : Type*} [group G] [mul_action G A] : mul_action G (A ‚Üí X) :=
{ smul := Œª g F a, F (g‚Åª¬π ‚Ä¢ a),
  one_smul := by simp only [one_inv, implies_true_iff, eq_self_iff_true, one_smul],
  mul_smul := by simp only [mul_smul, mul_inv_rev,
    forall_const, implies_true_iff, eq_self_iff_true] }

local attribute [instance] arrow_action

/-- Given groups `G X` with `G` acting on `A`,
    `G` acts by multiplicative automorphisms on `A ‚Üí X`. -/
def mul_aut_arrow {G A X} [group G] [mul_action G A] [group X] :
  G ‚Üí* mul_aut (A ‚Üí X) :=
{ to_fun := Œª g,
  { to_fun := Œª F, g ‚Ä¢ F,
    inv_fun := Œª F, g‚Åª¬π ‚Ä¢ F,
    left_inv := Œª F, inv_smul_smul g F,
    right_inv := Œª F, smul_inv_smul g F,
    map_mul' := by { intros, funext, simp only [arrow_action_to_has_scalar_smul, pi.mul_apply] } },
  map_one' := by { ext, simp only [mul_aut.one_apply, mul_equiv.coe_mk, one_smul]},
  map_mul' := by {intros, ext, simp only [mul_smul, mul_equiv.coe_mk, mul_aut.mul_apply] } }

@[simp] lemma mul_aut_arrow_apply {G A X : Type*} [group G] [mul_action G A] [group X]
  (g : G) (F : A ‚Üí X) (a : A) : mul_aut_arrow g F a = F (g‚Åª¬π ‚Ä¢ a) := rfl

/-- Given `G` acting on `A`, a functor from the corresponding action groupoid to a group `X`
    can be curried to a group homomorphism `G ‚Üí* (A ‚Üí X) ‚ãä G`. -/
def curry {G A X} [group G] [mul_action G A] [group X]
  (F : action_category G A ‚•§ single_obj X) :
  G ‚Üí* (A ‚Üí X) ‚ãä[mul_aut_arrow] G :=
have F_map_eq : ‚àÄ {a b} {f : a ‚ü∂ b}, F.map f = (F.map (hom_of_pair b.back f.val) : X) :=
  action_category.cases (Œª _ _, rfl),
{ to_fun := Œª g, ‚ü®Œª b, (F.map (hom_of_pair b g)), g‚ü©,
  map_one' := begin
    congr, funext,
    rw pi.one_apply,
    exact F_map_eq.symm.trans (F.map_id b),
  end,
  map_mul' := begin
    intros g h,
    congr, funext,
    rw pi.mul_apply,
    exact F_map_eq.symm.trans (F.map_comp (hom_of_pair (g‚Åª¬π ‚Ä¢ b) h) (hom_of_pair b g)),
  end }

/-- Given `G` acting on `A`, a group homomorphism `œÜ : G ‚Üí* (A ‚Üí X) ‚ãä G` can be uncurried to
    a functor from the action groupoid to `X`, provided that `œÜ g = (_, g)` for all `g`. -/
def uncurry {G A X} [group G] [mul_action G A] [group X]
  (F : G ‚Üí* (A ‚Üí X) ‚ãä[mul_aut_arrow] G)
  (sane : ‚àÄ g, (F g).right = g) :
  action_category G A ‚•§ single_obj X :=
{ obj := Œª _, (),
  map := Œª a b f, ((F f.val).left b.back),
  map_id' := by { intro x, rw [action_category.id_val, F.map_one], refl },
  map_comp' := by {
    intros x y z f g, revert y z g,
    refine action_category.cases _, intros,
    rw [action_category.comp_val, F.map_mul, mul_left, pi.mul_apply, mul_aut_arrow_apply, sane],
    refl } }

open is_free_group as fgp

instance action_category_is_free {G A : Type u} [group G] [is_free_group G] [mul_action G A] :
  is_free_groupoid (action_category G A) :=
{ generators := ‚ü®Œª a b, { e : fgp.generators G // fgp.of e ‚Ä¢ a.back = b.back }‚ü©,
  of := Œª a b e, ‚ü®fgp.of e, e.property‚ü©,
  unique_lift := begin
    introsI X _ f,
    let X' := (A ‚Üí X) ‚ãä[mul_aut_arrow] G,
    let f' : fgp.generators G ‚Üí X' := Œª e, ‚ü®Œª b, (@f (_ : A) b ‚ü®e, smul_inv_smul _ b‚ü©), fgp.of e‚ü©,
    rcases fgp.unique_lift f' with ‚ü®F', hF', uF'‚ü©,
    let F : action_category G A ‚•§ single_obj X := uncurry F' _,
    refine ‚ü®F, _, _‚ü©,
    { rintros ‚ü®‚ü®‚ü©, a : A‚ü© ‚ü®‚ü®‚ü©, b‚ü© ‚ü®e, h : fgp.of e ‚Ä¢ a = b‚ü©,
      change (F' (fgp.of _)).left _ = _,
      rw hF',
      cases (inv_smul_eq_iff.mpr h.symm),
      refl },
    { intros E hE,
      let E' := curry E,
      have : E' = F',
      { apply uF',
        intro e,
        refine semidirect_product.ext _ _ _ rfl,
        funext,
        exact hE _ _ ‚ü®e, _‚ü© },
      apply functor.hext,
      { intro, apply unit.ext },
      { refine action_category.cases _, intros,
        change _ == (F' _).left _,
        rw ‚Üêthis, refl } },
    { apply fgp.end_is_id (right_hom.comp F'),
      intro,
      rw [monoid_hom.comp_apply, hF'],
      refl }
  end }

end covering

section retract
open quiver

-- an abbreviation for taking the quiver corresponding to a subquiver
local notation T `‚ôØ` :10000 := T.quiver

variables {G : Type u} [groupoid.{u} G] [is_free_groupoid G]
  (T : wide_subquiver (generators.symmetrify : quiver G)) [arborescence T‚ôØ]

/-- A path in the tree gives a hom, by composition. -/
noncomputable def hom_of_path : Œ† {a : G}, T‚ôØ.path T‚ôØ.root a ‚Üí (T‚ôØ.root ‚ü∂ a)
| _ path.nil := ùüô _
| a (path.cons p ‚ü®sum.inl e, h‚ü©) := hom_of_path p ‚â´ of e
| a (path.cons p ‚ü®sum.inr e, h‚ü©) := hom_of_path p ‚â´ inv (of e)

/-- For every vertex `a`, there is a canonical hom from the root, given by the
    path in the tree. -/
def tree_hom (a : G) : T‚ôØ.root ‚ü∂ a := hom_of_path T (default _)

lemma tree_hom_eq {a : G} (p : T‚ôØ.path T‚ôØ.root a) : tree_hom T a = hom_of_path T p :=
by rw [tree_hom, unique.default_eq]

@[simp] lemma tree_hom_root : tree_hom T T‚ôØ.root = ùüô _ :=
trans (tree_hom_eq T path.nil) rfl -- ???

/-- Any hom in `G` can be made into a loop, by conjugating with `tree_hom`s. -/
@[simp] def loop_of_hom {a b : G} (p : a ‚ü∂ b) : End T‚ôØ.root :=
tree_hom T a ‚â´ p ‚â´ inv (tree_hom T b)

lemma loop_of_hom_eq_id {a b : G} {e : generators.arrow a b} :
  (sum.inl e) ‚àà T a b ‚à® (sum.inr e) ‚àà T b a
    ‚Üí loop_of_hom T (of e) = ùüô _ :=
begin
  rw [loop_of_hom, ‚Üêcategory.assoc, is_iso.comp_inv_eq, category.id_comp],
  rintro (h | h),
  { refine eq.trans _ (tree_hom_eq T (path.cons (default _) ‚ü®sum.inl e, h‚ü©)).symm,
    rw hom_of_path, refl },
  { rw tree_hom_eq T (path.cons (default _) ‚ü®sum.inr e, h‚ü©),
    simp only [hom_of_path, is_iso.inv_hom_id, category.comp_id, category.assoc, tree_hom] }
end

/-- Since a hom gives a loop, a homomorphism from the vertex group at the root
    extends to a functor on the whole groupoid. -/
@[simps] def functor_of_monoid_hom {X} [monoid X] (f : End T‚ôØ.root ‚Üí* X) :
  G ‚•§ single_obj X :=
{ obj := Œª _, (),
  map := Œª a b p, f (loop_of_hom T p),
  map_id' := begin intro a, convert f.map_one, simp end,
  map_comp' := by { intros, rw [single_obj.comp_as_mul, ‚Üêf.map_mul],
    simp only [is_iso.inv_hom_id_assoc, loop_of_hom, End.mul_def, category.assoc] } }

/-- Given a free groupoid and an arborescence of its generating quiver, the vertex
    group at the root is freely generated by loops coming from generating arrows
    in the complement of the tree. -/
def End_is_free_group_of_arborescence : is_free_group (End T‚ôØ.root) :=
{ generators := set.compl (wide_subquiver_equiv_set_total $ wide_subquiver_symmetrify T),
  of := Œª e, loop_of_hom T (of e.val.arrow),
  unique_lift := begin
    introsI X _ f,
    let f' : Œ† ‚¶Éa b : G‚¶Ñ, generators.arrow a b ‚Üí X := Œª a b e,
      if h : sum.inl e ‚àà T a b ‚à® sum.inr e ‚àà T b a then 1
      else f ‚ü®‚ü®a, b, e‚ü©, h‚ü©,
    rcases unique_lift f' with ‚ü®F', hF', uF'‚ü©,
    let F : End T‚ôØ.root ‚Üí* X := F'.map_End _,
    have sane : ‚àÄ {a b} (p : a ‚ü∂ b), (functor_of_monoid_hom T F).map p = F'.map p,
    { intros a b p,
      change F'.map _ = _,
      suffices : ‚àÄ {a} (p : T‚ôØ.path T‚ôØ.root a), F'.map (hom_of_path T p) = 1,
      { simp [this, tree_hom, single_obj.comp_as_mul, single_obj.inv_as_inv] },
      intros a p, induction p with b c p e ih,
      { apply F'.map_id },
      rcases e with ‚ü®e | e, eT‚ü©,
      { have : f' e = 1 := dif_pos (or.inl eT),
        simp only [hom_of_path, ih, hF', this, single_obj.comp_as_mul, mul_one, F'.map_comp] },
      { have : f' e = 1 := dif_pos (or.inr eT),
        simp [hom_of_path, ih, hF', this, single_obj.comp_as_mul, single_obj.inv_as_inv] } },
    refine ‚ü®F, _, _‚ü©,
    { intro e,
      convert sane _,
      rw hF',
      change _ = dite _ _ _,
      convert (dif_neg e.property).symm,
      apply congr_arg, ext; refl },
    { intros E hE,
      have : functor_of_monoid_hom T E = F',
      { apply uF',
        intros a b e,
        change E (loop_of_hom T _) = dite _ _ _,
        split_ifs,
        { rw loop_of_hom_eq_id T h, apply E.map_one },
        exact hE ‚ü®‚ü®a, b, e‚ü©, h‚ü© },
      ext,
      have : (functor_of_monoid_hom T E).map x = (functor_of_monoid_hom T F).map x,
      { rw [this, sane] },
      simpa using this }
  end }

end retract

open is_free_groupoid quotient_group

instance generators_connected (G) [groupoid.{u u} G] [is_connected G] [is_free_groupoid G] (r : G) :
  (generators : quiver G).symmetrify.rooted_connected r :=
begin
  let X := free_group (generators : quiver G).weakly_connected_component,
  let f : G ‚Üí X := Œª g, free_group.of ‚Üëg,
  let F : G ‚•§ single_obj X := single_obj.difference_functor f,
  have claim : F = (category_theory.functor.const G).obj (),
  { ext,
    rw [functor.const.obj_map, single_obj.id_as_one,
      single_obj.difference_functor_map, mul_inv_eq_one],
    apply congr_arg free_group.of,
    rw quiver.weakly_connected_component.eq,
    exact ‚ü®quiver.arrow.to_path (sum.inr e)‚ü© },
  refine ‚ü®Œª b, _‚ü©,
  rw ‚Üêquiver.weakly_connected_component.eq,
  apply free_group.of_injective,
  rw ‚Üêmul_inv_eq_one,
  rcases (infer_instance : nonempty (b ‚ü∂ r)) with ‚ü®p‚ü©,
  change F.map p = _,
  rw [claim, functor.const.obj_map, single_obj.id_as_one],
end

instance {G} [groupoid G] [is_free_groupoid G] [is_connected G] (r : G) : is_free_group (End r) :=
End_is_free_group_of_arborescence (quiver.geodesic_subtree _ r)

instance subgroup_is_free {G} [group.{u} G] [is_free_group G] (H : subgroup G) : is_free_group H :=
is_free_group.of_mul_equiv (End_mul_equiv_subgroup H)

end is_free_groupoid
